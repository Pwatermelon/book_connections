# Архитектура проекта Book Connections

## Общая структура

### Компоненты системы

```
book_connections/
│
├── app.py                  # Flask веб-сервер
├── main.py                 # CLI интерфейс
│
├── entity_extractor.py     # Извлечение именованных сущностей
├── relation_extractor.py   # Извлечение связей между сущностями
├── ontology_builder.py     # Построение онтологии и экспорт в OWL
├── graph_visualizer.py     # Визуализация графа
│
├── templates/
│   └── index.html          # Веб-интерфейс (HTML + CSS + JavaScript)
│
├── uploads/                # Временное хранилище загруженных файлов
├── results/                # Результаты анализа:
│   ├── *_graph.html        # Графы в формате HTML
│   ├── *_ontology.owl      # Онтологии в формате OWL
│   └── *.json              # Метаданные результатов
│
└── requirements.txt        # Зависимости Python
```

## Детальное описание компонентов

### 1. entity_extractor.py - Извлечение сущностей

**Назначение**: Извлечение именованных сущностей из текста (персоны, локации, организации)

**Используемые технологии:**
- **Natasha** (`natasha`): Основной NER-движок для русского языка
  - `Segmenter`: Токенизация текста
  - `MorphVocab`: Морфологический словарь
  - `NewsEmbedding`: Word embeddings для русского языка
  - `NewsMorphTagger`: Морфологический теггер
  - `NewsNERTagger`: Named Entity Recognition теггер
  - `Doc`: Объект документа для обработки

- **pymorphy2**: Морфологический анализатор русского языка
  - Используется для нормализации падежей
  - Проверка тегов имен собственных (Name, Surn)
  - Приведение к именительному падежу

- **transformers** (опционально): Резервный метод для NER
  - Модель: `surdan/rubert-base-ner` или аналогичные
  - Используется только если Natasha не находит персон

**Процесс работы:**

1. **Инициализация** (`__init__`):
   ```python
   - Создание компонентов Natasha
   - Инициализация pymorphy2 MorphAnalyzer
   - Подготовка transformers pipeline (если доступен)
   ```

2. **Извлечение сущностей** (`extract_entities`):
   ```
   Текст → Natasha (сегментация, морфология, NER) 
        → Получение spans с типами (PERSON, LOC, ORG)
        → Нормализация через pymorphy2
        → Резервный метод через морфологию (если нужно)
        → Группировка и дедупликация
        → Возврат словаря {TYPE: [entities]}
   ```

3. **Нормализация**:
   - `_get_normalized_form`: Приведение к именительному падежу через pymorphy2
   - `_normalize_persons`: Группировка персон по имени и фамилии
   - `_normalize_locations`: Объединение локаций в разных падежах

4. **Резервные методы**:
   - `_extract_persons_with_morphology`: Поиск персон через паттерны и морфологию
   - `_extract_persons_with_transformers`: Использование transformers моделей

**Формат вывода:**
```python
{
    'PERSON': [
        {
            'text': 'Иван Петров',      # Оригинальный текст
            'start': 100,                # Позиция начала
            'end': 111,                  # Позиция конца
            'normalized': 'Иван Петров', # Нормализованная форма
            'mentions_count': 5          # Количество упоминаний
        },
        ...
    ],
    'LOC': [...],
    'ORG': [...]
}
```

---

### 2. relation_extractor.py - Извлечение связей

**Назначение**: Поиск и классификация связей между сущностями

**Методология**: Извлечение только явно упомянутых связей через ключевые слова

**Типы связей и их ключевые слова:**

1. **RESIDENCE** (Проживание):
   - Ключевые слова: `из`, `в`, `живёт`, `живет`, `проживает`, `родом`, `родился`, `родилась`, `уроженец`, `уроженка`, `жил`, `жила`, `жили`, `живут`, `находится`
   - Английские: `from`, `lives in`, `born in`, `resides in`, `native of`

2. **FAMILY** (Родство):
   - Ключевые слова: `брат`, `сестра`, `мать`, `отец`, `сын`, `дочь`, `родственники`, `родственник`, `семья`, `родители`, `дед`, `бабушка`, `внук`, `внучка`, `дядя`, `тётя`
   - Английские: `brother`, `sister`, `mother`, `father`, `son`, `daughter`, `family`, `relative`, `parent`, `grandfather`, `grandmother`, `uncle`, `aunt`

3. **FRIENDSHIP** (Дружба):
   - Ключевые слова: `друзья`, `друг`, `подруга`, `знаком`, `встретил`, `встретила`, `знал`, `знала`
   - Английские: `friends`, `friend`, `met`, `know`, `knew`, `acquaintance`

4. **WORK** (Работа):
   - Ключевые слова: `коллеги`, `коллега`, `работал`, `работала`, `начальник`, `подчинённый`
   - Английские: `colleagues`, `colleague`, `worked`, `boss`, `employee`, `manager`

5. **LOVE** (Любовь):
   - Ключевые слова: `любовь`, `любит`, `любил`, `любила`, `влюблён`, `влюблена`, `полюбил`, `полюбила`, `жена`, `муж`, `женился`, `вышла замуж`
   - Английские: `love`, `loves`, `loved`, `married`, `wife`, `husband`

**Процесс работы:**

1. **Извлечение связей персон с локациями** (`_extract_person_location_relations`):
   ```
   Для каждой персоны:
     - Найти все упоминания в тексте
     - Для каждого упоминания взять контекст ±400 символов
     - Найти ключевые слова RESIDENCE в контексте
     - В окне ±150 символов от ключевого слова найти локацию
     - Создать связь RESIDENCE
     - Создать обратную связь HAS_RESIDENT
   ```

2. **Извлечение связей между персонами** (`_extract_person_person_relations`):
   ```
   Для каждой пары персон:
     - Найти все упоминания обеих персон
     - Для каждого упоминания взять контекст ±400 символов
     - Найти ключевые слова связи (FAMILY, FRIENDSHIP, WORK, LOVE)
     - В окне ±150 символов от ключевого слова найти вторую персону
     - Проверить расстояние между упоминаниями (<600 символов)
     - Создать связь соответствующего типа
   ```

3. **Создание двусторонних связей** (`_create_bidirectional_relations`):
   - Для каждой связи создается обратная (если применимо)
   - Симметричные связи (FAMILY, FRIENDSHIP) остаются как есть
   - Асимметричные связи получают обратные типы

**Формат вывода:**
```python
[
    {
        'source': 'Иван Петров',
        'target': 'Саратов',
        'type': 'RESIDENCE',
        'confidence': 0.75,
        'context': 'Иван Петров родился в Саратове...',
        'source_type': 'PERSON',
        'target_type': 'LOC'
    },
    {
        'source': 'Саратов',
        'target': 'Иван Петров',
        'type': 'HAS_RESIDENT',
        ...
    },
    ...
]
```

---

### 3. ontology_builder.py - Построение онтологии

**Назначение**: Построение структурированной онтологии и экспорт в OWL

**Используемые технологии:**
- **owlready2**: Работа с онтологиями OWL/RDF
  - Создание классов, свойств, индивидов
  - Экспорт в RDF/XML формат

**Процесс работы:**

1. **Построение онтологии** (`build_ontology`):
   ```
   Сущности + Связи → Онтология (словарь Python)
   
   Структура онтологии:
   {
       'entities': {
           'Иван Петров': {
               'type': 'PERSON',
               'attributes': {
                   'mentions': 15,
                   'first_mention': 100,
                   'total_relations': 5,
                   'relation_types': {'FRIENDSHIP': 2, 'FAMILY': 1, ...}
               }
           },
           ...
       },
       'relations': [...],
       'relation_types': ['RESIDENCE', 'FAMILY', ...]
   }
   ```

2. **Экспорт в OWL** (`export_to_owl`):
   ```
   Python онтология → owlready2 объекты → RDF/XML файл
   
   Создаются:
   - Классы: Person, Location, Organization
   - Объектные свойства: 
     * hasResidence (Person → Location)
     * hasResident (Location → Person)
     * hasFamily (Person → Person, симметричное)
     * hasFriend (Person → Person, симметричное)
     * worksWith (Person → Person)
     * loves (Person → Person)
   - Индивиды: все найденные сущности
   - Факты: все связи между сущностями
   ```

**Классы OWL:**
```python
Person = onto.Person          # Класс для персон
Location = onto.Location      # Класс для локаций
Organization = onto.Organization  # Класс для организаций
```

**Объектные свойства:**
```python
hasResidence = onto.hasResidence      # Person → Location
hasResident = onto.hasResident        # Location → Person (обратное)
hasFamily = onto.hasFamily            # Person → Person (симметричное)
hasFriend = onto.hasFriend            # Person → Person (симметричное)
worksWith = onto.worksWith            # Person → Person
loves = onto.loves                    # Person → Person
```

---

### 4. graph_visualizer.py - Визуализация графа

**Назначение**: Создание интерактивного графа связей

**Используемые технологии:**
- **NetworkX**: Построение графа, алгоритмы раскладки
- **Plotly**: Интерактивная визуализация (HTML)

**Процесс работы:**

1. **Построение графа** (`build_graph`):
   ```
   Онтология → NetworkX граф
   
   Узлы (nodes):
   - entity_name: имя сущности
   - type: тип сущности (PERSON, LOC, ORG)
   - color: цвет по типу
   - mentions: количество упоминаний
   - total_relations: количество связей
   
   Рёбра (edges):
   - type: тип связи
   - color: цвет по типу связи
   - label: текстовое описание связи
   - confidence: уверенность
   - context: контекст из текста
   ```

2. **Визуализация** (`visualize_interactive`):
   ```
   NetworkX граф → Plotly визуализация → HTML файл
   
   Алгоритмы раскладки:
   - spring_layout: По умолчанию (силы притяжения/отталкивания)
   - circular_layout: Круговая раскладка
   - kamada_kawai_layout: Оптимальная раскладка
   - spectral_layout: Спектральная раскладка
   ```

**Цветовая схема:**

Сущности:
- `PERSON`: #FF6B6B (красный)
- `LOC`: #4ECDC4 (бирюзовый)
- `ORG`: #45B7D1 (голубой)

Связи:
- `RESIDENCE` / `HAS_RESIDENT`: #E74C3C (красный)
- `FAMILY`: #9B59B6 (фиолетовый)
- `FRIENDSHIP`: #3498DB (синий)
- `WORK`: #F39C12 (оранжевый)
- `LOVE`: #E91E63 (розовый)

**Особенности визуализации:**
- Подписи на рёбрах (типы связей)
- Размер узлов зависит от количества связей
- Интерактивность: hover для деталей, zoom, pan
- Легенда справа с типами сущностей
- Плавные кривые линии (spline)

---

### 5. app.py - Веб-сервер

**Назначение**: Flask веб-приложение для загрузки и обработки файлов

**Маршруты:**
- `GET /`: Главная страница (index.html)
- `POST /upload`: Обработка загрузки файла

**Процесс обработки запроса:**

```
1. Загрузка файла → uploads/
2. Определение кодировки (chardet или перебор)
3. Чтение текста
4. Вызов process_book():
   a. EntityExtractor.extract_entities()
   b. RelationExtractor.extract_relations()
   c. OntologyBuilder.build_ontology()
   d. OntologyBuilder.export_to_owl()
   e. GraphVisualizer.build_graph()
   f. GraphVisualizer.visualize_interactive()
5. Сохранение результатов в results/
6. Возврат JSON с путями к файлам
```

**Функции:**
- `read_text_file`: Чтение файла с автоопределением кодировки
- `process_book`: Основная функция обработки
- `upload_file`: Обработчик POST запроса

**Формат ответа:**
```json
{
    "success": true,
    "filename": "book.txt",
    "text_length": 50000,
    "statistics": {
        "total_entities": 50,
        "total_relations": 30,
        "entity_types": {"PERSON": 20, "LOC": 25, "ORG": 5},
        "relation_types": {"RESIDENCE": 10, "FAMILY": 5, ...}
    },
    "graph_file": "results/book_123456_graph.html",
    "owl_file": "results/book_123456_ontology.owl"
}
```

---

### 6. main.py - CLI интерфейс

**Назначение**: Командная строка для обработки файлов

**Использование:**
```bash
python main.py <путь_к_файлу.txt> [выходной_граф.html]
```

**Процесс:**
```
1. Загрузка текста из файла
2. Извлечение сущностей
3. Извлечение связей
4. Построение онтологии
5. Сохранение онтологии в ontology.txt
6. Визуализация графа
7. Вывод статистики в консоль
```

---

### 7. templates/index.html - Веб-интерфейс

**Технологии:**
- HTML5
- CSS3 (темная тема, минималистичный дизайн)
- Vanilla JavaScript (без фреймворков)

**Функциональность:**
- Drag-and-drop загрузка файлов
- Показ выбранного файла
- Кнопка анализа
- Отображение статистики
- Встроенный iframe с графом
- Кнопка скачивания OWL файла

**AJAX запросы:**
- POST /upload для отправки файла
- Получение JSON с результатами
- Динамическое отображение статистики и графа

---

## Поток данных

```
Текстовый файл (.txt)
    ↓
[read_text_file] → Определение кодировки → Текст (str)
    ↓
[EntityExtractor.extract_entities]
    → Natasha NER
    → pymorphy2 нормализация
    → Словарь сущностей {TYPE: [entities]}
    ↓
[RelationExtractor.extract_relations]
    → Поиск ключевых слов
    → Сопоставление сущностей в контексте
    → Список связей
    ↓
[OntologyBuilder.build_ontology]
    → Структурированная онтология (dict)
    → Экспорт в OWL (owlready2)
    ↓
[GraphVisualizer.build_graph]
    → NetworkX граф
    ↓
[GraphVisualizer.visualize_interactive]
    → Plotly фигура
    → HTML файл
    ↓
Результаты:
    - graph.html (интерактивный граф)
    - ontology.owl (OWL онтология)
    - results.json (метаданные)
```

---

## Модели и алгоритмы

### Natasha
- **Модель**: NewsEmbedding (векторные представления слов)
- **Токенизация**: Segmenter
- **Морфология**: NewsMorphTagger
- **NER**: NewsNERTagger
- **Язык**: Русский
- **Лицензия**: MIT

### pymorphy2
- **Тип**: Морфологический анализатор
- **Язык**: Русский
- **Функции**: Лемматизация, определение тегов, нормализация падежей

### Transformers (опционально)
- **Модель**: `surdan/rubert-base-ner` или аналогичные
- **Тип**: BERT-based NER для русского языка
- **Использование**: Резервный метод при неудаче Natasha

### NetworkX
- **Алгоритмы раскладки**:
  - `spring_layout`: Force-directed (Fruchterman-Reingold)
  - `kamada_kawai_layout`: Оптимальная раскладка
  - `circular_layout`: Круговая
  - `spectral_layout`: Спектральная

---

## Производительность

**Зависит от:**
- Размера текста (линейная сложность)
- Количества сущностей (O(n²) для связей между персонами)
- Нагрузки на систему (загрузка моделей Natasha)

**Примерное время обработки:**
- Небольшой текст (10-50 KB): 5-15 секунд
- Средний текст (100-500 KB): 30-90 секунд
- Большой текст (1+ MB): 2-5 минут

**Оптимизации:**
- Ограничение количества проверяемых упоминаний (первые 20-50)
- Ограничение контекста поиска (±400 символов)
- Ленивая загрузка transformers моделей

---

## Расширяемость

**Добавление новых типов связей:**
1. Добавить ключевые слова в `relation_extractor.py`
2. Добавить цвет в `graph_visualizer.py`
3. Добавить свойство в `ontology_builder.py`

**Добавление новых типов сущностей:**
1. Natasha автоматически поддерживает различные типы
2. Добавить цвет в `graph_visualizer.py`
3. Добавить класс в `ontology_builder.py`

**Улучшение точности:**
- Использовать более мощные NER модели
- Добавить обученные классификаторы для типов связей
- Использовать синтаксический парсинг для улучшения контекста

